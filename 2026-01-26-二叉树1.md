<img width="1400" height="1140" alt="image" src="https://github.com/user-attachments/assets/16944e3c-6335-4ee9-9b10-4931e973e98d" />
## 二叉树理论基础
- 二叉树种类
   - 满二叉树：
      1. 如果一个二叉树只有degree 为0 或者2的结点，且degree为0的在同一层上
      2. 深度为k, 有2^k-1的结点
   - 完全二叉树
      1. 除了最底层，其他层都含有最大值的节点。 并且最下层的节点都集中在左边位置。若最底层为h， 则该层含有1~2^（h-1)
  - 二叉搜索树
      1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
      2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
      3. 它的左、右子树也分别为二叉排序树
  - 平衡二叉搜索树
      1. 又被称为AVL（Adelson-Velsky and Landis）树
      2. 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
- 二叉树的储存方式
   1. 链式： 指针
   2. 顺序： 数组
- 遍历方式
   1. BFS：
   2. DFS：前序遍历（中左右），中序遍历（左中右），后序遍历（左右中）

&nbsp;

## 前序遍历
```

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node):
            if node is None:
                return
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return res
```

## 后序遍历

```
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node):
            if node is None:
                return

            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        dfs(root)
        return res
```

## 中序遍历
```
   def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            res.append(node.val)
            dfs(node.right)
        dfs(root)
        return res
```
