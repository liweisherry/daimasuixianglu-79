## 110. Balanced Binary Tree
- é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.com/problems/balanced-binary-tree/

### ğŸ’­ First Thought
- è¿™é¢˜ç›®éœ€è¦ååºéå†ï¼Œ å› ä¸ºéœ€è¦leftå’Œrightçš„è¿”å›ç»“æœè¿›è¡Œæ¯”è¾ƒ

### âœ… Final Approach
```
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        return self.check(root) != -1
    
    def check(self, root):
        if root is None:
            return 0
        left_height = self.check(root.left)
        right_height = self.check(root.right)
        if left_height == -1 or right_height == -1:
            return -1
        if abs(left_height - right_height) >1:
            return -1
        else:
            return 1 + max(left_height, right_height)

```

&nbsp;
## 257. Binary Tree Paths
- é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.com/problems/binary-tree-paths/

### ğŸ’­ First Thought
- è¿™é¢˜ç›®éœ€è¦å‰åºéå†

### âœ… Final Approach
```
       def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        path = []
        if not root:
            return res
        self.traversal(root, path, res)
        return res
    
    def traversal(self, root, path, res):
        path.append(root.val) #ä¸­é—´
        if not root.left and not root.right:
            spath = '->'.join(map(str,path))
            res.append(spath)
            return 
        
        if root.left:
            self.traversal(root.left, path, res)
            path.pop()
        if root.right:
            self.traversal(root.right, path, res)
            path.pop()       


```

### âš ï¸ Mistakes / Gotchas
- ä½¿ç”¨functionsæ¥è¿è¡Œè®¡ç®—
### Complexity
Time: O(n)

&nbsp;
